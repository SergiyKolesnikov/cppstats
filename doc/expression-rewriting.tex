% ___ PLEASE README ________________________________________________________________
%
% Latex:
%   I use lualatex (successor of pdflatex) of texlive-2013.
%
% Formatting:
%   I use a new line for each sentence and have hard line-wrapping at 86 characters
%   enabled. Feel free to append modelines for your editor at the end of the file.
%
%	Only one thing: please try to get your editor to respect the current newline
%	character of a document or to use LF newlines (Unix style), as merging becomes
%	really hell otherwise.
%___________________________________________________________________________________

\documentclass[a4paper]{scrartcl}

% title
\title{Handling \ifdef Expressions\\in \cppstats}
\author{Claus Hunsen\\\url{hunsen@fim.uni-passau.de}}
\date{September 2014}

% Packages
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{xspace}
\usepackage{graphicx}
\usepackage{xcolor}
\usepackage{fancyvrb}
\usepackage{fixltx2e} % fix textsub- and -superscript
\usepackage{paralist} % for inline lists
\usepackage{listings}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{hyperref}


% fixing commands (sub- and super-scripts)

\newcommand\super[1]{\textsuperscript{#1}}
\newcommand\sub[1]{\textsubscript{#1}}
\newcommand\supersub[2]{\rlap{\super{#1}}\sub{#2}}


% own commands

% todo
\newcommand{\todo}[1]{{\color{red}{\textbf{\textit{[#1]}}}}}
\newcommand{\TODO}[1]{\todo{#1}}
\newcommand{\todots}{\todo{\ldots}}
\frenchspacing

% typesetting
\newcommand\code[1]{\texttt{#1}}
\newcommand\feature[1]{\texttt{#1}}
\newcommand\tool[1]{\textsc{#1}}
\newcommand\metric[1]{{#1}}

%instantiations
\newcommand\ifdeff[1]{\code{\##1}\xspace}
\newcommand\ifdef[0]{{\upshape\ifdeff{ifdef}}\xspace}
\newcommand\ifdefs[0]{\ifdef{}s\xspace}

\newcommand\cppstats[0]{\tool{cppstats}\xspace}
\newcommand\cpp{\tool{cpp}\xspace}


% listings

\lstset{
  basicstyle=\ttfamily\small,
  keywordstyle=\ttfamily\small\bfseries,
  commentstyle=\ttfamily\small\itshape,
  escapechar=@,
  tabsize=2,
  numbers=left,
  firstline=1,
  rulesepcolor=\color{black},
  backgroundcolor=\color{white},
  numbersep=0.65em,
  xleftmargin=0.5em,
%  xrightmargin=1em,
  frame=top|bottom|left|right,
  showstringspaces=false,
  mathescape=true,
  columns=fullflexible,
%  escapeinside={(*@}{@*)},
  otherkeywords={endif, ifdef, elif, else, define, ifndef, defined, \#}
}

% remove warnings

\addtokomafont{sectioning}{\rmfamily} % for \ifdef in section headings



\begin{document}

\maketitle



\begin{footnotesize}
\noindent \cppstats was initially developed by J\"org Liebig at University of Passau for a set of studies \cite{LiebigALKS10,LiebigKA11}.
In 2013, Claus Hunsen from the same university has taken over development.
The most current version of \cppstats is available at \url{https://github.com/clhunsen/cppstats/}.
Further information can be found at \url{http://fosd.net/cppstats}.
\end{footnotesize}

\section{Introduction}
\cppstats is a tool for analyzing software systems regarding their variability.
Therefore, we focus on software systems written in \tool{C} using the capabilities of the \cpp (the \tool{C} preprocessor) to express variability.
\cppstats handles the expressions of the \cpp inclusion-guards (\ifdeff{if}, \ifdeff{elif}, \ifdeff{endif}, etc.) in a special way, which is why we provide the used procedure in this document.\footnote{We mainly describe the mechanism that are performed in the \tool{GENERAL} analysis (\code{analyses/general.py}) as the main analysis of \cppstats, but the mechanisms relate to the other analyses, too.}
The handling directly affect the scattering and tangling analyses of \cppstats.

There is handling of \ifdef expressions within \cppstats during three different parts of the whole program:
\begin{inparaenum}[\itshape 1\upshape)]
\item light adaption of the expressions during \textit{preparation} part of \cppstats, before generating \tool{srcML} files from the source code;
\item collecting the expressions from the \tool{srcML} files and rewriting them by making implicit tangling explicit; and
\item building a global expression pool for the analyzed software-project.
\end{inparaenum}



\section{Example}

As \ifdefs are explained best by means of an example, the three common pattern of \cpp usage are shown in Figure~\ref{fig:examples}.
Each part of the example is present in a different file.
Part~(a) shows nesting of \ifdefs, while Part~(b) and~(c) show the use of \ifdeff{else} and \ifdeff{elif} branches in an \ifdef cascade.

During this document, the reader is referenced to these small examples to illustrate all matters.

\begin{figure}[ht]
        \centering
        \begin{subfigure}[b]{0.3\textwidth}
					\begin{lstlisting}[language=C]
#ifdef A
	#ifdef B
	#endif
#endif
#ifdef A
#endif
					\end{lstlisting}
					\caption{Nested \ifdef in file\,\code{X.c}.\\\,}
					\label{fig:examples:a}
        \end{subfigure}
        \hfill
        \begin{subfigure}[b]{0.3\textwidth}
					\begin{lstlisting}[language=C, firstnumber=5]
#if  defined(A) \
		 && defined(B)
#else 
#endif
					\end{lstlisting}
					\caption{\ifdeff{else} branch in file\,\code{Y.c}.\\\,}
					\label{fig:examples:b}
        \end{subfigure}
				\hfill
        \begin{subfigure}[b]{0.3\textwidth}
					\begin{lstlisting}[language=C, firstnumber=8]
#ifndef Z_H
#define Z_H
#ifdef C
#elif defined(D)
#endif
#endif // Z_H
					\end{lstlisting}
					\caption{\ifdeff{elif} branch and include~guard in file\,\code{Z.h}.}
					\label{fig:examples:c}
        \end{subfigure}     
        
        \caption{Short examples of the patterns that occur while using \cpp and that are treated by \cppstats. 
        	Each example and their rewriting rules are explained in this very document.}
        \label{fig:examples}
\end{figure}



\section{Source-Code Preparation to \tool{srcML} files}
\label{sec:preparation}

The first part of a \cppstats run is the source-code preparation that transforms the plain-text source code to \tool{srcML}\footnote{http://www.srcml.org/} files.
\tool{srcML} is an XML format for source code that preserves line numbers and preprocessor information.

Before transforming the source code to \tool{srcML}, there are several code-normalization steps, which heavily depend on the code analysis to be performed.
For the different preparation types, please refer to the file \code{preparation.py} of \cppstats.

There are up to three possible steps in the preparation that can have effect on the \ifdef expressions, though all have only cosmetic effect:
\begin{inparaenum}[\itshape 1\upshape)]
\item the handling of multi-line expressions;
\item the rewriting of the shortcut expressions \ifdeff{ifdef} and \ifdeff{ifndef}; and
\item the removal of include guards.
\end{inparaenum}

After all steps of the preparation, \cppstats has generated proper \tool{srcML} files for each source file.
Based on these files, \cppstats performs the analyses.


\subsection{Multi-Line \ifdef Expressions {\footnotesize (\code{preparations/rewriteMultilineMacros.py})}}

A multi-line \ifdef expression is shown in Fig.\ \ref{fig:examples:b} on Lines~5 and~6.
This expressions is rewritten as a single-line expression, so that \cppstats does not have to handle line breaks in \ifdef expressions later.
The line numbers are preserved during this step.

The output, after applying this change to Fig.\ \ref{fig:multiline:a}, is shown in Fig.\ \ref{fig:multiline:b}.

\begin{figure}[ht]
  \centering
  \begin{subfigure}[b]{0.45\textwidth}
		\begin{lstlisting}[language=C, firstnumber=5]
#if defined(A) \
		 && defined(B)
#else 
#endif
		\end{lstlisting}
		\caption{Repetition of Fig.\ \ref{fig:examples:b}, containing a multi-line expression on Lines 5 and 6.}
		\label{fig:multiline:a}
  \end{subfigure}
  \hfill
  \begin{subfigure}[b]{0.45\textwidth}
		\begin{lstlisting}[language=C, firstnumber=5]
#if defined(A) && defined(B)

#else 
#endif
		\end{lstlisting}
		\caption{The same code with single-line expressions.}
		\label{fig:multiline:b}
  \end{subfigure}
  
  \caption{An \ifdeff{else} branch in file\,\code{Y}, (a) before and (b) after rewriting multi-line expressions into single-line fashion.}
  
\end{figure}


\subsection{Rewriting of \ifdeff{ifdef} and \ifdeff{ifndef} {\footnotesize (\code{preparations/rewriteIfdefs.py})}}

As another step, the \ifdef expressions are more streamlined by rewriting the conditionals \ifdeff{ifdef} and \ifdeff{ifndef} to their long forms.
This yields \ifdeff{if defined(X)} for the conditional \ifdeff{ifdef X}, and \ifdeff{if\,!defined(Y)} for \ifdeff{ifndef Y}.


\subsection{Removal of Include Guards {\footnotesize (\code{preparations/deleteIncludeGuards.py})}}

The last preparation step that affects \ifdef expressions is the removal of include guards.
Include guards are used to prevent the multiple inclusion of header files and would bias the results of \cppstats, because they are not a mechanism to implement variability.

An inclusion guard, as shown in Fig.\ \ref{fig:examples:c} consists of three parts:
\begin{inparaenum}[\itshape 1\upshape)]
\item a conditional-inclusion guard checking if the file was already included (Line~8);
\item the definition of the file guard for that is checked in Line~8 (Line~9); and
\item the closing \ifdeff{endif} for the \ifdeff{ifndef} (Line~13).
\end{inparaenum}

When a header file containing this construct is included again, the conditional in Line~8 will be false, because \feature{Z\_H} is already defined.
The preprocessor will skip over the entire contents of the file, and the compiler will not see it twice.

As a result of this preparation step, the source-code lines corresponding to the include guard (Lines 8, 9, and 13) are removed from the file and exchanged with blank lines, so that line numbers are preserved.



\section{Processing of Expressions During File Analysis}
\label{sec:processing}

\cppstats performs its analyses based on the \tool{srcML} files that are generated at the end of the preparation step.
The \ifdef expressions are collected while traversing the \tool{XML} tree of the input files, the main functionality is implemented in the function \code{\_getFeatures} (\code{analyses/general.py}, Lines 565ff.).
During this action, the nesting hierarchy of the conditionals is remembered and used to rewrite the \ifdef expressions accordingly in the function \code{\_getFeatureSignature} (Lines~479ff.).
Implicit tangling of \ifdef expressions are made explicit in this step, while preserving all nesting-depth information.

For example, \cppstats rewrites all nested \ifdefs, each with a condition that conjoins their own conditional expression with the enclosing ones, because the inner expression depends on the evaluation of its own condition and, additionally, on the evaluation of the surrounding \ifdef expression.
This is done also for \ifdeff{else} and \ifdeff{elif} expressions.
 
The result of these mechanisms is shown in Fig.\ \ref{fig:examples2}.

\begin{figure}[ht]
        \centering
        \begin{subfigure}[t]{\textwidth}
					\begin{lstlisting}[language=C]
#if defined(A)
	#if defined(A) && defined(B)
	#endif
#endif
#if defined(A)
#endif
					\end{lstlisting}
					\caption{Nested \ifdef in file\,\code{X.c}.\vspace{1em}}
					\label{fig:examples2:a}
        \end{subfigure}
        \vspace{1em}
        \begin{subfigure}[t]{\textwidth}
					\begin{lstlisting}[language=C, firstnumber=5]
#if defined(A) && defined(B)

#elif !(defined(A) && defined(B))
#endif
					\end{lstlisting}
					\caption{\ifdeff{else} branch in file\,\code{Y.c}.}
					\label{fig:examples2:b}
        \end{subfigure}
        \begin{subfigure}[t]{\textwidth}
					\begin{lstlisting}[language=C, firstnumber=8]


#if defined(C)
#elif (!(defined(C))) && (defined(D))
#endif

					\end{lstlisting}
					\caption{\ifdeff{elif} branch and include~guard in file\,\code{Z.h}.}
					\label{fig:examples2:c}
        \end{subfigure}
        
        \caption{Rewritten \ifdef expressions from Fig.\ \ref{fig:examples}, also including all changes from Section~\ref{sec:preparation}.\\
        				{\footnotesize (Note that the files are formatted as \tool{srcML} actually, but, for better understanding, the source-code representations are shown here.)}}
        \label{fig:examples2}
\end{figure}



\section{Global \ifdef Expression Pool}
\label{sec:pool}

There are two steps for building a global pool of expressions:
\begin{inparaenum}[\itshape 1\upshape)]
\item constructing a list of \ifdef expressions per file; and
\item combining all file list to a global pool.
\end{inparaenum}


\subsection{Listing of \ifdef Expressions per File}

The first step is already processed during the mechanisms of Section~\ref{sec:processing}:
Each distinct \ifdef expression is added to the list of expressions per file only once!
The equality of expressions is checked via string equality (\code{wrapFeatureUp} in \code{analyses/general.py}, Lines~592ff.).
Accordingly, the expression list for the file \code{X.c} from Fig.\ \ref{fig:examples2:a} is \feature{[defined(A), defined(A) \&\& defined(B)]}.
Note that the second expression \feature{defined(A)} from Line~5 is \textbf{not} added.


\subsection{Construction of Global Expression Pool}

After a file is processed entirely and its list of expressions is built, the list is added to the global pool of expressions in \code{\_mergeFeatures} (\code{analyses/general.py}, Lines~1175ff.).
Afterwards, the processed \ifdef expressions from Fig.\ \ref{fig:examples2} are added to a global pool of expressions called \code{sigmap} (Line~1172).
The resulting global pool for scattering and tangling analyses is shown in Fig.\ \ref{fig:pool}.

\begin{figure}
\begin{lstlisting}
(defined(A)) && (defined(B))
defined(A) && defined(B)
(!(defined(C))) && (defined(D))
!(defined(A) && defined(B))
defined(A)
defined(C)
\end{lstlisting}
\caption{The resulting (unordered) global expression pool for the example files from Fig.\ \ref*{fig:examples} that is used for tangling and scattering analyses.}
\label{fig:pool}
\end{figure}


%\section{Notes on the Nesting Analysis}
%
%For the nesting analysis, the resulting global pool from Section~\ref{sec:pool} is used, but the nesting depth of each \ifdef block is inserted into a global list.
%This way, the nesting analysis is totally independent of the actual \ifdef expressions that are contained by the global pool, as they are not important for this analysis.
%
%The global list of nesting depths for the example files from Fig.\ \ref{fig:examples} is \code{[[1, 2, 1], [1], [1]]}.
%This list is used to obtain the average nesting depth of a system, for example (\metric{ND\sub{avg}} is $1.2$, here).

\bibliographystyle{alpha}
\bibliography{references}


\end{document}
